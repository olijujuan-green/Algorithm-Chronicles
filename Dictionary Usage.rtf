{\rtf1\ansi\ansicpg1252\cocoartf2638
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 HelveticaNeue;\f2\fmodern\fcharset0 Courier;
\f3\fnil\fcharset0 HelveticaNeue-Italic;\f4\fmodern\fcharset0 Courier-Oblique;\f5\fnil\fcharset0 HelveticaNeue-BoldItalic;
\f6\fnil\fcharset0 HelveticaNeue-Bold;}
{\colortbl;\red255\green255\blue255;\red29\green38\blue42;\red255\green255\blue255;\red67\green91\blue103;
\red245\green247\blue249;}
{\*\expandedcolortbl;;\cssrgb\c14902\c19608\c21961;\cssrgb\c100000\c100000\c100000;\cssrgb\c32941\c43137\c47843;
\cssrgb\c96863\c97647\c98039;}
\margl1440\margr1440\vieww27680\viewh16620\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Dictionary Usage\
\
A dictionary in swift is an unordered collection of items that stores its elements as [key : value] pairs. You get it? Like an actual dictionary where the key is the word and the value is its meaning. How clever. They are even more valuable for their speed than they are for their structure. Sometimes you will use a dictionary for it\'92s speed alone, storing data as keys and just setting the value to true. It these cases it doesn\'92t matter what the value is, you just need to be able to access its elements in constant time. A good example of this is the leetcode question \'93Two Sum\'94. \
\
Two Sum Prompt:\
\pard\pardeftab720\sa280\partightenfactor0

\f1\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Given an array of integers\'a0
\f2\fs26 \cf4 \cb5 \strokec4 nums
\f1\fs28 \cf2 \cb3 \strokec2 \'a0and an integer\'a0
\f2\fs26 \cf4 \cb5 \strokec4 target
\f1\fs28 \cf2 \cb3 \strokec2 , return\'a0
\f3\i indices of the two numbers such that they add up to\'a0
\f4\fs26 \cf4 \cb5 \strokec4 target
\f1\i0\fs28 \cf2 \cb3 \strokec2 .\
You may assume that each input would have\'a0
\f5\i\b exactly
\f6\i0 \'a0one solution
\f1\b0 , and you may not use the\'a0
\f3\i same
\f1\i0 \'a0element twice.\
You can return the answer in any order.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \
This problem can be solved with nested for loops. But that approach is unacceptably slow (O
\fs26 n^2). \
\
Spoiler below:\
A much better solution to the problem is use a dictionary to store the numbers in the array, comparing them with the difference from target number and returning them if they sum to the target \
\
func twoSum(_ nums: [Int], _ target: Int) -> [Int] \{\
        \
        var dict = [Int : Int]()\
        \
        for (i, n) in nums.enumerated() \{\
            var difference = target - n\
            \
            if dict[difference] != nil \{\
                return [dict[difference]!, i]\
            \}\
            dict[n] = i\
        \}\
        return []\
    \}\
\
\
Conclusion:\
If you get stuck, try throwing a dictionary at the problem.\
}